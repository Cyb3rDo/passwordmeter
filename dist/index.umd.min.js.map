{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 6d34f30b011929478a88","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","reverse","string","newstring","s","length","charAt","checkPass","password","minLength","arguments","undefined","nAlphaUC","nAlphaLC","nNumber","nSymbol","nMidChar","nUnqChar","nRepChar","nRepInc","nConsecAlphaUC","nConsecAlphaLC","nConsecNumber","nConsecSymbol","nConsecCharType","nSeqAlpha","nSeqNumber","nSeqSymbol","nSeqChar","nReqChar","nMultMidChar","nMultConsecAlphaUC","nMultConsecAlphaLC","nMultConsecNumber","nMultSeqAlpha","nMultSeqNumber","nMultSeqSymbol","nMultLength","nMultNumber","nMultSymbol","nTmpAlphaUC","nTmpAlphaLC","nTmpNumber","nTmpSymbol","sAlphas","sNumerics","sSymbols","nScore","parseInt","nLength","arrPwd","replace","split","arrPwdLen","a","match","bCharExists","b","Math","abs","ceil","sFwd","substring","sRev","toLowerCase","indexOf","arrChars","arrCharsIds","arrCharsLen","minVal","nMinReqChars","nRequirements"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,cAAAD,IAEAD,EAAA,cAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,GAEtB,YExDD,SAASe,GAAQC,GAEb,IAAK,GADDC,GAAY,GACPC,EAAE,EAAGA,EAAIF,EAAOG,OAAQD,IAC7BD,EAAYD,EAAOI,OAAOF,GAAKD,CAEnC,OAAOA,GAGXhB,EAAOD,SAQHqB,UAAW,SAAUC,GAAyB,GAAfC,GAAeC,UAAAL,OAAA,GAAAM,SAAAD,UAAA,GAAAA,UAAA,GAAH,CACvC,KAAKF,EACD,QAqBJ,KAAK,GAhBDI,GAAS,EAAGC,EAAS,EAAGC,EAAQ,EAAGC,EAAQ,EAAGC,EAAS,EAAGC,EAAS,EAAGC,EAAS,EAAGC,EAAQ,EAAGC,EAAe,EAAGC,EAAe,EAAGC,EAAc,EAAGC,EAAc,EAAGC,EAAgB,EAAGC,EAAU,EAAGC,EAAW,EAAGC,EAAW,EAAGC,EAAS,EAAGC,EAAS,EAClPC,EAAa,EAAGC,EAAmB,EAAGC,EAAmB,EAAGC,EAAkB,EAC9EC,EAAc,EAAGC,EAAe,EAAGC,EAAe,EAClDC,EAAY,EAAGC,EAAY,EAC3BC,EAAY,EACdC,EAAY,GAAIC,EAAY,GAAIC,EAAW,GAAIC,EAAW,GACxDC,EAAU,6BACVC,EAAY,cACZC,EAAW,cAEbC,EAASC,SAASxC,EAASH,OAASgC,GAClCY,EAAUzC,EAASH,OACnB6C,EAAS1C,EAAS2C,QAAQ,OAAO,IAAIC,MAAM,OAC3CC,EAAYH,EAAO7C,OAGhBiD,EAAE,EAAGA,EAAID,EAAWC,IAAK,CAC1BJ,EAAOI,GAAGC,MAAM,WACI,KAAhBf,GAA2BA,EAAc,GAAMc,IAAKlC,IAAkBI,KAC1EgB,EAAcc,EACd1C,KAEKsC,EAAOI,GAAGC,MAAM,WACD,KAAhBd,GAA2BA,EAAc,GAAMa,IAAKjC,IAAkBG,KAC1EiB,EAAca,EACdzC,KAEKqC,EAAOI,GAAGC,MAAM,WACjBD,EAAI,GAAKA,EAAKD,EAAY,GAAMrC,IACjB,KAAf0B,GAA0BA,EAAa,GAAMY,IAAKhC,IAAiBE,KACvEkB,EAAaY,EACbxC,KAEKoC,EAAOI,GAAGC,MAAM,oBACjBD,EAAI,GAAKA,EAAKD,EAAY,GAAMrC,IACjB,KAAf2B,GAA0BA,EAAa,GAAMW,IAAK/B,IAAiBC,KACvEmB,EAAaW,EACbvC,IAIJ,KAAK,GADDyC,IAAc,EACTC,EAAE,EAAGA,EAAIJ,EAAWI,IACrBP,EAAOI,IAAMJ,EAAOO,IAAMH,GAAKG,IAC/BD,GAAc,EAOdrC,GAAWuC,KAAKC,IAAIN,GAAWI,EAAEH,IAGrCE,KACAtC,IACAD,EAAWoC,EAAUnC,EACrBC,EAAWF,EAAYyC,KAAKE,KAAKzC,EAAQF,GAAYyC,KAAKE,KAAKzC,IAKvE,IAAK,GAAIf,GAAE,EAAGA,EAAI,GAAIA,IAAK,CACvB,GAAIyD,GAAOjB,EAAQkB,UAAU1D,EAAE4C,SAAS5C,EAAE,IACtC2D,EAAO9D,EAAQ4D,EACfrD,GAASwD,cAAcC,QAAQJ,QAAerD,EAASwD,cAAcC,QAAQF,SAAetC,IAAaG,KAIjH,IAAK,GAAIxB,GAAE,EAAGA,EAAI,EAAGA,IAAK,CACtB,GAAIyD,GAAOhB,EAAUiB,UAAU1D,EAAE4C,SAAS5C,EAAE,IACxC2D,EAAO9D,EAAQ4D,EACfrD,GAASwD,cAAcC,QAAQJ,QAAerD,EAASwD,cAAcC,QAAQF,SAAerC,IAAcE,KAIlH,IAAK,GAAIxB,GAAE,EAAGA,EAAI,EAAGA,IAAK,CACtB,GAAIyD,GAAOf,EAASgB,UAAU1D,EAAE4C,SAAS5C,EAAE,IACvC2D,EAAO9D,EAAQ4D,EACfrD,GAASwD,cAAcC,QAAQJ,QAAerD,EAASwD,cAAcC,QAAQF,SAAepC,IAAcC,KAM9GhB,EAAW,GAAKA,EAAWqC,IAC3BF,EAASC,SAASD,EAAiC,GAAtBE,EAAUrC,KAEvCC,EAAW,GAAKA,EAAWoC,IAC3BF,EAASC,SAASD,EAAiC,GAAtBE,EAAUpC,KAEvCC,EAAU,GAAKA,EAAUmC,IACzBF,EAASC,SAASD,EAAUjC,EAAUwB,IAEtCvB,EAAU,IACVgC,EAASC,SAASD,EAAUhC,EAAUwB,IAEtCvB,EAAW,IACX+B,EAASC,SAASD,EAAU/B,EAAWc,KAItCjB,EAAW,GAAKD,EAAW,IAAkB,IAAZG,GAA6B,IAAZD,IACnDiC,EAASC,SAASD,EAASE,IAEd,IAAbpC,GAA+B,IAAbD,GAA8B,IAAZG,GAAiBD,EAAU,IAC/DiC,EAASC,SAASD,EAASE,IAE3B/B,EAAW,IACX6B,EAASC,SAASD,EAAS5B,IAE3BC,EAAiB,IACjB2B,EAASC,SAASD,EAAU3B,EAAiBW,IAE7CV,EAAiB,IACjB0B,EAASC,SAASD,EAAU1B,EAAiBW,IAE7CV,EAAgB,IAChByB,EAASC,SAASD,EAAUzB,EAAgBW,IAE5CR,EAAY,IACZsB,EAASC,SAASD,EAAUtB,EAAYS,IAExCR,EAAa,IACbqB,EAASC,SAASD,EAAUrB,EAAaS,IAEzCR,EAAa,IACboB,EAASC,SAASD,EAAUpB,EAAaS,GAG7C,IAAI8B,WAAUC,UAAaC,SAG3BF,KAAYjB,EAAQrC,EAASC,EAASC,EAAQC,GAC9CoD,IAAe,UAAU,WAAW,WAAW,UAAU,WACzDC,GAAcF,GAAS7D,MACvB,KAAK,GAAIN,IAAE,EAAGA,GAAIqE,GAAarE,KAAK,CAChC,GAAIsE,GAC+BA,IAAb,WAAlBF,GAAYpE,IAA4BiD,SAASvC,EAAY,GAAsB,EACnFyD,GAASnE,KAAMiD,SAASqB,GAAS,GAAMxC,IAClCqC,GAASnE,IAAKiD,SAASqB,GAAS,IAAMxC,IAEnD,GACIyC,IADAC,GAAgB1C,CASpB,OAPoCyC,IAAhC9D,EAASH,QAAUI,EAA4B,EAA2B,EAC1E8D,GAAgBD,KAChBvB,EAASC,SAASD,EAA0B,EAAhBwB,KAG5BxB,EAAS,IAAOA,EAAS,IAAgBA,EAAS,IAAKA,EAAS,GAE7DA","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"passwordMeter\"] = factory();\n\telse\n\t\troot[\"passwordMeter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"passwordMeter\"] = factory();\n\telse\n\t\troot[\"passwordMeter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction reverse(string) {\n\t    var newstring = \"\";\n\t    for (var s = 0; s < string.length; s++) {\n\t        newstring = string.charAt(s) + newstring;\n\t    }\n\t    return newstring;\n\t}\n\t\n\tmodule.exports = {\n\t    /**\n\t     * Check password's strength\n\t     *\n\t     * @param {String} password\n\t     * @param {Number} minLength - minimum password length\n\t     * @returns {Number} - from 0 to 100 and -1 for an empty password\n\t     */\n\t    checkPass: function checkPass(password) {\n\t        var minLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n\t\n\t        if (!password) {\n\t            return -1;\n\t        }\n\t\n\t        // The code below almost identical to the `chkPass(pwd)` function from http://www.passwordmeter.com/js/pwdmeter.js\n\t\n\t        var nAlphaUC = 0,\n\t            nAlphaLC = 0,\n\t            nNumber = 0,\n\t            nSymbol = 0,\n\t            nMidChar = 0,\n\t            nUnqChar = 0,\n\t            nRepChar = 0,\n\t            nRepInc = 0,\n\t            nConsecAlphaUC = 0,\n\t            nConsecAlphaLC = 0,\n\t            nConsecNumber = 0,\n\t            nConsecSymbol = 0,\n\t            nConsecCharType = 0,\n\t            nSeqAlpha = 0,\n\t            nSeqNumber = 0,\n\t            nSeqSymbol = 0,\n\t            nSeqChar = 0,\n\t            nReqChar = 0;\n\t        var nMultMidChar = 2,\n\t            nMultConsecAlphaUC = 2,\n\t            nMultConsecAlphaLC = 2,\n\t            nMultConsecNumber = 2;\n\t        var nMultSeqAlpha = 3,\n\t            nMultSeqNumber = 3,\n\t            nMultSeqSymbol = 3;\n\t        var nMultLength = 4,\n\t            nMultNumber = 4;\n\t        var nMultSymbol = 6;\n\t        var nTmpAlphaUC = \"\",\n\t            nTmpAlphaLC = \"\",\n\t            nTmpNumber = \"\",\n\t            nTmpSymbol = \"\";\n\t        var sAlphas = \"abcdefghijklmnopqrstuvwxyz\";\n\t        var sNumerics = \"01234567890\";\n\t        var sSymbols = \")!@#$%^&*()\";\n\t\n\t        var nScore = parseInt(password.length * nMultLength);\n\t        var nLength = password.length;\n\t        var arrPwd = password.replace(/\\s+/g, \"\").split(/\\s*/);\n\t        var arrPwdLen = arrPwd.length;\n\t\n\t        /* Loop through password to check for Symbol, Numeric, Lowercase and Uppercase pattern matches */\n\t        for (var a = 0; a < arrPwdLen; a++) {\n\t            if (arrPwd[a].match(/[A-Z]/g)) {\n\t                if (nTmpAlphaUC !== \"\") {\n\t                    if (nTmpAlphaUC + 1 == a) {\n\t                        nConsecAlphaUC++;nConsecCharType++;\n\t                    }\n\t                }\n\t                nTmpAlphaUC = a;\n\t                nAlphaUC++;\n\t            } else if (arrPwd[a].match(/[a-z]/g)) {\n\t                if (nTmpAlphaLC !== \"\") {\n\t                    if (nTmpAlphaLC + 1 == a) {\n\t                        nConsecAlphaLC++;nConsecCharType++;\n\t                    }\n\t                }\n\t                nTmpAlphaLC = a;\n\t                nAlphaLC++;\n\t            } else if (arrPwd[a].match(/[0-9]/g)) {\n\t                if (a > 0 && a < arrPwdLen - 1) {\n\t                    nMidChar++;\n\t                }\n\t                if (nTmpNumber !== \"\") {\n\t                    if (nTmpNumber + 1 == a) {\n\t                        nConsecNumber++;nConsecCharType++;\n\t                    }\n\t                }\n\t                nTmpNumber = a;\n\t                nNumber++;\n\t            } else if (arrPwd[a].match(/[^a-zA-Z0-9_]/g)) {\n\t                if (a > 0 && a < arrPwdLen - 1) {\n\t                    nMidChar++;\n\t                }\n\t                if (nTmpSymbol !== \"\") {\n\t                    if (nTmpSymbol + 1 == a) {\n\t                        nConsecSymbol++;nConsecCharType++;\n\t                    }\n\t                }\n\t                nTmpSymbol = a;\n\t                nSymbol++;\n\t            }\n\t            /* Internal loop through password to check for repeat characters */\n\t            var bCharExists = false;\n\t            for (var b = 0; b < arrPwdLen; b++) {\n\t                if (arrPwd[a] == arrPwd[b] && a != b) {\n\t                    /* repeat character exists */\n\t                    bCharExists = true;\n\t                    /*\n\t                     Calculate icrement deduction based on proximity to identical characters\n\t                     Deduction is incremented each time a new match is discovered\n\t                     Deduction amount is based on total password length divided by the\n\t                     difference of distance between currently selected match\n\t                     */\n\t                    nRepInc += Math.abs(arrPwdLen / (b - a));\n\t                }\n\t            }\n\t            if (bCharExists) {\n\t                nRepChar++;\n\t                nUnqChar = arrPwdLen - nRepChar;\n\t                nRepInc = nUnqChar ? Math.ceil(nRepInc / nUnqChar) : Math.ceil(nRepInc);\n\t            }\n\t        }\n\t\n\t        /* Check for sequential alpha string patterns (forward and reverse) */\n\t        for (var s = 0; s < 23; s++) {\n\t            var sFwd = sAlphas.substring(s, parseInt(s + 3));\n\t            var sRev = reverse(sFwd);\n\t            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) {\n\t                nSeqAlpha++;nSeqChar++;\n\t            }\n\t        }\n\t\n\t        /* Check for sequential numeric string patterns (forward and reverse) */\n\t        for (var _s = 0; _s < 8; _s++) {\n\t            var _sFwd = sNumerics.substring(_s, parseInt(_s + 3));\n\t            var _sRev = reverse(_sFwd);\n\t            if (password.toLowerCase().indexOf(_sFwd) != -1 || password.toLowerCase().indexOf(_sRev) != -1) {\n\t                nSeqNumber++;nSeqChar++;\n\t            }\n\t        }\n\t\n\t        /* Check for sequential symbol string patterns (forward and reverse) */\n\t        for (var _s2 = 0; _s2 < 8; _s2++) {\n\t            var _sFwd2 = sSymbols.substring(_s2, parseInt(_s2 + 3));\n\t            var _sRev2 = reverse(_sFwd2);\n\t            if (password.toLowerCase().indexOf(_sFwd2) != -1 || password.toLowerCase().indexOf(_sRev2) != -1) {\n\t                nSeqSymbol++;nSeqChar++;\n\t            }\n\t        }\n\t\n\t        /* Modify overall score value based on usage vs requirements */\n\t\n\t        /* General point assignment */\n\t        if (nAlphaUC > 0 && nAlphaUC < nLength) {\n\t            nScore = parseInt(nScore + (nLength - nAlphaUC) * 2);\n\t        }\n\t        if (nAlphaLC > 0 && nAlphaLC < nLength) {\n\t            nScore = parseInt(nScore + (nLength - nAlphaLC) * 2);\n\t        }\n\t        if (nNumber > 0 && nNumber < nLength) {\n\t            nScore = parseInt(nScore + nNumber * nMultNumber);\n\t        }\n\t        if (nSymbol > 0) {\n\t            nScore = parseInt(nScore + nSymbol * nMultSymbol);\n\t        }\n\t        if (nMidChar > 0) {\n\t            nScore = parseInt(nScore + nMidChar * nMultMidChar);\n\t        }\n\t\n\t        /* Point deductions for poor practices */\n\t        if ((nAlphaLC > 0 || nAlphaUC > 0) && nSymbol === 0 && nNumber === 0) {\n\t            // Only Letters\n\t            nScore = parseInt(nScore - nLength);\n\t        }\n\t        if (nAlphaLC === 0 && nAlphaUC === 0 && nSymbol === 0 && nNumber > 0) {\n\t            // Only Numbers\n\t            nScore = parseInt(nScore - nLength);\n\t        }\n\t        if (nRepChar > 0) {\n\t            // Same character exists more than once\n\t            nScore = parseInt(nScore - nRepInc);\n\t        }\n\t        if (nConsecAlphaUC > 0) {\n\t            // Consecutive Uppercase Letters exist\n\t            nScore = parseInt(nScore - nConsecAlphaUC * nMultConsecAlphaUC);\n\t        }\n\t        if (nConsecAlphaLC > 0) {\n\t            // Consecutive Lowercase Letters exist\n\t            nScore = parseInt(nScore - nConsecAlphaLC * nMultConsecAlphaLC);\n\t        }\n\t        if (nConsecNumber > 0) {\n\t            // Consecutive Numbers exist\n\t            nScore = parseInt(nScore - nConsecNumber * nMultConsecNumber);\n\t        }\n\t        if (nSeqAlpha > 0) {\n\t            // Sequential alpha strings exist (3 characters or more)\n\t            nScore = parseInt(nScore - nSeqAlpha * nMultSeqAlpha);\n\t        }\n\t        if (nSeqNumber > 0) {\n\t            // Sequential numeric strings exist (3 characters or more)\n\t            nScore = parseInt(nScore - nSeqNumber * nMultSeqNumber);\n\t        }\n\t        if (nSeqSymbol > 0) {\n\t            // Sequential symbol strings exist (3 characters or more)\n\t            nScore = parseInt(nScore - nSeqSymbol * nMultSeqSymbol);\n\t        }\n\t\n\t        var arrChars = void 0,\n\t            arrCharsIds = void 0,\n\t            arrCharsLen = void 0;\n\t\n\t        /* Determine if mandatory requirements have been met and set image indicators accordingly */\n\t        arrChars = [nLength, nAlphaUC, nAlphaLC, nNumber, nSymbol];\n\t        arrCharsIds = [\"nLength\", \"nAlphaUC\", \"nAlphaLC\", \"nNumber\", \"nSymbol\"];\n\t        arrCharsLen = arrChars.length;\n\t        for (var c = 0; c < arrCharsLen; c++) {\n\t            var minVal;\n\t            if (arrCharsIds[c] == \"nLength\") {\n\t                minVal = parseInt(minLength - 1);\n\t            } else {\n\t                minVal = 0;\n\t            }\n\t            if (arrChars[c] == parseInt(minVal + 1)) {\n\t                nReqChar++;\n\t            } else if (arrChars[c] > parseInt(minVal + 1)) {\n\t                nReqChar++;\n\t            }\n\t        }\n\t        var nRequirements = nReqChar;\n\t        var nMinReqChars;\n\t        if (password.length >= minLength) {\n\t            nMinReqChars = 3;\n\t        } else {\n\t            nMinReqChars = 4;\n\t        }\n\t        if (nRequirements > nMinReqChars) {\n\t            // One or more required characters exist\n\t            nScore = parseInt(nScore + nRequirements * 2);\n\t        }\n\t\n\t        if (nScore > 100) {\n\t            nScore = 100;\n\t        } else if (nScore < 0) {\n\t            nScore = 0;\n\t        }\n\t\n\t        return nScore;\n\t    }\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.umd.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6d34f30b011929478a88\n **/","function reverse(string) {\n    var newstring = \"\";\n    for (var s=0; s < string.length; s++) {\n        newstring = string.charAt(s) + newstring;\n    }\n    return newstring;\n}\n\nmodule.exports = {\n    /**\n     * Check password's strength\n     *\n     * @param {String} password\n     * @param {Number} minLength - minimum password length\n     * @returns {Number} - from 0 to 100 and -1 for an empty password\n     */\n    checkPass: function (password, minLength = 8) {\n        if (!password) {\n            return -1;\n        }\n\n        // The code below almost identical to the `chkPass(pwd)` function from http://www.passwordmeter.com/js/pwdmeter.js\n\n        let nAlphaUC=0, nAlphaLC=0, nNumber=0, nSymbol=0, nMidChar=0, nUnqChar=0, nRepChar=0, nRepInc=0, nConsecAlphaUC=0, nConsecAlphaLC=0, nConsecNumber=0, nConsecSymbol=0, nConsecCharType=0, nSeqAlpha=0, nSeqNumber=0, nSeqSymbol=0, nSeqChar=0, nReqChar=0;\n        const nMultMidChar=2, nMultConsecAlphaUC=2, nMultConsecAlphaLC=2, nMultConsecNumber=2;\n        const nMultSeqAlpha=3, nMultSeqNumber=3, nMultSeqSymbol=3;\n        const nMultLength=4, nMultNumber=4;\n        const nMultSymbol=6;\n        let nTmpAlphaUC=\"\", nTmpAlphaLC=\"\", nTmpNumber=\"\", nTmpSymbol=\"\";\n        const sAlphas = \"abcdefghijklmnopqrstuvwxyz\";\n        const sNumerics = \"01234567890\";\n        const sSymbols = \")!@#$%^&*()\";\n\n        let nScore = parseInt(password.length * nMultLength);\n        const nLength = password.length;\n        const arrPwd = password.replace(/\\s+/g,\"\").split(/\\s*/);\n        const arrPwdLen = arrPwd.length;\n\n        /* Loop through password to check for Symbol, Numeric, Lowercase and Uppercase pattern matches */\n        for (var a=0; a < arrPwdLen; a++) {\n            if (arrPwd[a].match(/[A-Z]/g)) {\n                if (nTmpAlphaUC !== \"\") { if ((nTmpAlphaUC + 1) == a) { nConsecAlphaUC++; nConsecCharType++; } }\n                nTmpAlphaUC = a;\n                nAlphaUC++;\n            }\n            else if (arrPwd[a].match(/[a-z]/g)) {\n                if (nTmpAlphaLC !== \"\") { if ((nTmpAlphaLC + 1) == a) { nConsecAlphaLC++; nConsecCharType++; } }\n                nTmpAlphaLC = a;\n                nAlphaLC++;\n            }\n            else if (arrPwd[a].match(/[0-9]/g)) {\n                if (a > 0 && a < (arrPwdLen - 1)) { nMidChar++; }\n                if (nTmpNumber !== \"\") { if ((nTmpNumber + 1) == a) { nConsecNumber++; nConsecCharType++; } }\n                nTmpNumber = a;\n                nNumber++;\n            }\n            else if (arrPwd[a].match(/[^a-zA-Z0-9_]/g)) {\n                if (a > 0 && a < (arrPwdLen - 1)) { nMidChar++; }\n                if (nTmpSymbol !== \"\") { if ((nTmpSymbol + 1) == a) { nConsecSymbol++; nConsecCharType++; } }\n                nTmpSymbol = a;\n                nSymbol++;\n            }\n            /* Internal loop through password to check for repeat characters */\n            var bCharExists = false;\n            for (var b=0; b < arrPwdLen; b++) {\n                if (arrPwd[a] == arrPwd[b] && a != b) { /* repeat character exists */\n                    bCharExists = true;\n                    /*\n                     Calculate icrement deduction based on proximity to identical characters\n                     Deduction is incremented each time a new match is discovered\n                     Deduction amount is based on total password length divided by the\n                     difference of distance between currently selected match\n                     */\n                    nRepInc += Math.abs(arrPwdLen/(b-a));\n                }\n            }\n            if (bCharExists) {\n                nRepChar++;\n                nUnqChar = arrPwdLen-nRepChar;\n                nRepInc = (nUnqChar) ? Math.ceil(nRepInc/nUnqChar) : Math.ceil(nRepInc);\n            }\n        }\n\n        /* Check for sequential alpha string patterns (forward and reverse) */\n        for (let s=0; s < 23; s++) {\n            let sFwd = sAlphas.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqAlpha++; nSeqChar++;}\n        }\n\n        /* Check for sequential numeric string patterns (forward and reverse) */\n        for (let s=0; s < 8; s++) {\n            let sFwd = sNumerics.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqNumber++; nSeqChar++;}\n        }\n\n        /* Check for sequential symbol string patterns (forward and reverse) */\n        for (let s=0; s < 8; s++) {\n            let sFwd = sSymbols.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqSymbol++; nSeqChar++;}\n        }\n\n        /* Modify overall score value based on usage vs requirements */\n\n        /* General point assignment */\n        if (nAlphaUC > 0 && nAlphaUC < nLength) {\n            nScore = parseInt(nScore + ((nLength - nAlphaUC) * 2));\n        }\n        if (nAlphaLC > 0 && nAlphaLC < nLength) {\n            nScore = parseInt(nScore + ((nLength - nAlphaLC) * 2));\n        }\n        if (nNumber > 0 && nNumber < nLength) {\n            nScore = parseInt(nScore + (nNumber * nMultNumber));\n        }\n        if (nSymbol > 0) {\n            nScore = parseInt(nScore + (nSymbol * nMultSymbol));\n        }\n        if (nMidChar > 0) {\n            nScore = parseInt(nScore + (nMidChar * nMultMidChar));\n        }\n\n        /* Point deductions for poor practices */\n        if ((nAlphaLC > 0 || nAlphaUC > 0) && nSymbol === 0 && nNumber === 0) {  // Only Letters\n            nScore = parseInt(nScore - nLength);\n        }\n        if (nAlphaLC === 0 && nAlphaUC === 0 && nSymbol === 0 && nNumber > 0) {  // Only Numbers\n            nScore = parseInt(nScore - nLength);\n        }\n        if (nRepChar > 0) {  // Same character exists more than once\n            nScore = parseInt(nScore - nRepInc);\n        }\n        if (nConsecAlphaUC > 0) {  // Consecutive Uppercase Letters exist\n            nScore = parseInt(nScore - (nConsecAlphaUC * nMultConsecAlphaUC));\n        }\n        if (nConsecAlphaLC > 0) {  // Consecutive Lowercase Letters exist\n            nScore = parseInt(nScore - (nConsecAlphaLC * nMultConsecAlphaLC));\n        }\n        if (nConsecNumber > 0) {  // Consecutive Numbers exist\n            nScore = parseInt(nScore - (nConsecNumber * nMultConsecNumber));\n        }\n        if (nSeqAlpha > 0) {  // Sequential alpha strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqAlpha * nMultSeqAlpha));\n        }\n        if (nSeqNumber > 0) {  // Sequential numeric strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqNumber * nMultSeqNumber));\n        }\n        if (nSeqSymbol > 0) {  // Sequential symbol strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqSymbol * nMultSeqSymbol));\n        }\n\n        let arrChars, arrCharsIds, arrCharsLen;\n\n        /* Determine if mandatory requirements have been met and set image indicators accordingly */\n        arrChars = [nLength,nAlphaUC,nAlphaLC,nNumber,nSymbol];\n        arrCharsIds = [\"nLength\",\"nAlphaUC\",\"nAlphaLC\",\"nNumber\",\"nSymbol\"];\n        arrCharsLen = arrChars.length;\n        for (let c=0; c < arrCharsLen; c++) {\n            var minVal;\n            if (arrCharsIds[c] == \"nLength\") { minVal = parseInt(minLength - 1); } else { minVal = 0; }\n            if (arrChars[c] == parseInt(minVal + 1)) { nReqChar++;}\n            else if (arrChars[c] > parseInt(minVal + 1)) { nReqChar++;}\n        }\n        let nRequirements = nReqChar;\n        var nMinReqChars;\n        if (password.length >= minLength) { nMinReqChars = 3; } else { nMinReqChars = 4; }\n        if (nRequirements > nMinReqChars) {  // One or more required characters exist\n            nScore = parseInt(nScore + (nRequirements * 2));\n        }\n\n        if (nScore > 100) { nScore = 100; } else if (nScore < 0) { nScore = 0; }\n\n        return nScore;\n    }\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}