{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b193c466cd4930c43c30","webpack:///./src/index.js"],"names":["reverse","string","newstring","s","length","charAt","module","exports","checkPass","password","minLength","nAlphaUC","nAlphaLC","nNumber","nSymbol","nMidChar","nUnqChar","nRepChar","nRepInc","nConsecAlphaUC","nConsecAlphaLC","nConsecNumber","nConsecSymbol","nConsecCharType","nSeqAlpha","nSeqNumber","nSeqSymbol","nSeqChar","nReqChar","nMultMidChar","nMultConsecAlphaUC","nMultConsecAlphaLC","nMultConsecNumber","nMultSeqAlpha","nMultSeqNumber","nMultSeqSymbol","nMultLength","nMultNumber","nMultSymbol","nTmpAlphaUC","nTmpAlphaLC","nTmpNumber","nTmpSymbol","sAlphas","sNumerics","sSymbols","nScore","parseInt","nLength","arrPwd","replace","split","arrPwdLen","a","match","bCharExists","b","Math","abs","ceil","sFwd","substring","sRev","toLowerCase","indexOf","arrChars","arrCharsIds","arrCharsLen","c","minVal","nRequirements","nMinReqChars"],"mappings":"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","file":"index.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"passwordMeter\"] = factory();\n\telse\n\t\troot[\"passwordMeter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b193c466cd4930c43c30\n **/","function reverse(string) {\n    var newstring = \"\";\n    for (var s=0; s < string.length; s++) {\n        newstring = string.charAt(s) + newstring;\n    }\n    return newstring;\n}\n\nmodule.exports = {\n    /**\n     * Check password's strength\n     *\n     * @param {String} password\n     * @param {Number} minLength - minimum password length\n     * @returns {Number} - from 0 to 100 and -1 for an empty password\n     */\n    checkPass: function (password, minLength = 8) {\n        if (!password) {\n            return -1;\n        }\n\n        // The code below almost identical to the `chkPass(pwd)` function from http://www.passwordmeter.com/js/pwdmeter.js\n\n        let nAlphaUC=0, nAlphaLC=0, nNumber=0, nSymbol=0, nMidChar=0, nUnqChar=0, nRepChar=0, nRepInc=0, nConsecAlphaUC=0, nConsecAlphaLC=0, nConsecNumber=0, nConsecSymbol=0, nConsecCharType=0, nSeqAlpha=0, nSeqNumber=0, nSeqSymbol=0, nSeqChar=0, nReqChar=0;\n        const nMultMidChar=2, nMultConsecAlphaUC=2, nMultConsecAlphaLC=2, nMultConsecNumber=2;\n        const nMultSeqAlpha=3, nMultSeqNumber=3, nMultSeqSymbol=3;\n        const nMultLength=4, nMultNumber=4;\n        const nMultSymbol=6;\n        let nTmpAlphaUC=\"\", nTmpAlphaLC=\"\", nTmpNumber=\"\", nTmpSymbol=\"\";\n        const sAlphas = \"abcdefghijklmnopqrstuvwxyz\";\n        const sNumerics = \"01234567890\";\n        const sSymbols = \")!@#$%^&*()\";\n\n        let nScore = parseInt(password.length * nMultLength);\n        const nLength = password.length;\n        const arrPwd = password.replace(/\\s+/g,\"\").split(/\\s*/);\n        const arrPwdLen = arrPwd.length;\n\n        /* Loop through password to check for Symbol, Numeric, Lowercase and Uppercase pattern matches */\n        for (var a=0; a < arrPwdLen; a++) {\n            if (arrPwd[a].match(/[A-Z]/g)) {\n                if (nTmpAlphaUC !== \"\") { if ((nTmpAlphaUC + 1) == a) { nConsecAlphaUC++; nConsecCharType++; } }\n                nTmpAlphaUC = a;\n                nAlphaUC++;\n            }\n            else if (arrPwd[a].match(/[a-z]/g)) {\n                if (nTmpAlphaLC !== \"\") { if ((nTmpAlphaLC + 1) == a) { nConsecAlphaLC++; nConsecCharType++; } }\n                nTmpAlphaLC = a;\n                nAlphaLC++;\n            }\n            else if (arrPwd[a].match(/[0-9]/g)) {\n                if (a > 0 && a < (arrPwdLen - 1)) { nMidChar++; }\n                if (nTmpNumber !== \"\") { if ((nTmpNumber + 1) == a) { nConsecNumber++; nConsecCharType++; } }\n                nTmpNumber = a;\n                nNumber++;\n            }\n            else if (arrPwd[a].match(/[^a-zA-Z0-9_]/g)) {\n                if (a > 0 && a < (arrPwdLen - 1)) { nMidChar++; }\n                if (nTmpSymbol !== \"\") { if ((nTmpSymbol + 1) == a) { nConsecSymbol++; nConsecCharType++; } }\n                nTmpSymbol = a;\n                nSymbol++;\n            }\n            /* Internal loop through password to check for repeat characters */\n            var bCharExists = false;\n            for (var b=0; b < arrPwdLen; b++) {\n                if (arrPwd[a] == arrPwd[b] && a != b) { /* repeat character exists */\n                    bCharExists = true;\n                    /*\n                     Calculate icrement deduction based on proximity to identical characters\n                     Deduction is incremented each time a new match is discovered\n                     Deduction amount is based on total password length divided by the\n                     difference of distance between currently selected match\n                     */\n                    nRepInc += Math.abs(arrPwdLen/(b-a));\n                }\n            }\n            if (bCharExists) {\n                nRepChar++;\n                nUnqChar = arrPwdLen-nRepChar;\n                nRepInc = (nUnqChar) ? Math.ceil(nRepInc/nUnqChar) : Math.ceil(nRepInc);\n            }\n        }\n\n        /* Check for sequential alpha string patterns (forward and reverse) */\n        for (let s=0; s < 23; s++) {\n            let sFwd = sAlphas.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqAlpha++; nSeqChar++;}\n        }\n\n        /* Check for sequential numeric string patterns (forward and reverse) */\n        for (let s=0; s < 8; s++) {\n            let sFwd = sNumerics.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqNumber++; nSeqChar++;}\n        }\n\n        /* Check for sequential symbol string patterns (forward and reverse) */\n        for (let s=0; s < 8; s++) {\n            let sFwd = sSymbols.substring(s,parseInt(s+3));\n            let sRev = reverse(sFwd);\n            if (password.toLowerCase().indexOf(sFwd) != -1 || password.toLowerCase().indexOf(sRev) != -1) { nSeqSymbol++; nSeqChar++;}\n        }\n\n        /* Modify overall score value based on usage vs requirements */\n\n        /* General point assignment */\n        if (nAlphaUC > 0 && nAlphaUC < nLength) {\n            nScore = parseInt(nScore + ((nLength - nAlphaUC) * 2));\n        }\n        if (nAlphaLC > 0 && nAlphaLC < nLength) {\n            nScore = parseInt(nScore + ((nLength - nAlphaLC) * 2));\n        }\n        if (nNumber > 0 && nNumber < nLength) {\n            nScore = parseInt(nScore + (nNumber * nMultNumber));\n        }\n        if (nSymbol > 0) {\n            nScore = parseInt(nScore + (nSymbol * nMultSymbol));\n        }\n        if (nMidChar > 0) {\n            nScore = parseInt(nScore + (nMidChar * nMultMidChar));\n        }\n\n        /* Point deductions for poor practices */\n        if ((nAlphaLC > 0 || nAlphaUC > 0) && nSymbol === 0 && nNumber === 0) {  // Only Letters\n            nScore = parseInt(nScore - nLength);\n        }\n        if (nAlphaLC === 0 && nAlphaUC === 0 && nSymbol === 0 && nNumber > 0) {  // Only Numbers\n            nScore = parseInt(nScore - nLength);\n        }\n        if (nRepChar > 0) {  // Same character exists more than once\n            nScore = parseInt(nScore - nRepInc);\n        }\n        if (nConsecAlphaUC > 0) {  // Consecutive Uppercase Letters exist\n            nScore = parseInt(nScore - (nConsecAlphaUC * nMultConsecAlphaUC));\n        }\n        if (nConsecAlphaLC > 0) {  // Consecutive Lowercase Letters exist\n            nScore = parseInt(nScore - (nConsecAlphaLC * nMultConsecAlphaLC));\n        }\n        if (nConsecNumber > 0) {  // Consecutive Numbers exist\n            nScore = parseInt(nScore - (nConsecNumber * nMultConsecNumber));\n        }\n        if (nSeqAlpha > 0) {  // Sequential alpha strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqAlpha * nMultSeqAlpha));\n        }\n        if (nSeqNumber > 0) {  // Sequential numeric strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqNumber * nMultSeqNumber));\n        }\n        if (nSeqSymbol > 0) {  // Sequential symbol strings exist (3 characters or more)\n            nScore = parseInt(nScore - (nSeqSymbol * nMultSeqSymbol));\n        }\n\n        let arrChars, arrCharsIds, arrCharsLen;\n\n        /* Determine if mandatory requirements have been met and set image indicators accordingly */\n        arrChars = [nLength,nAlphaUC,nAlphaLC,nNumber,nSymbol];\n        arrCharsIds = [\"nLength\",\"nAlphaUC\",\"nAlphaLC\",\"nNumber\",\"nSymbol\"];\n        arrCharsLen = arrChars.length;\n        for (let c=0; c < arrCharsLen; c++) {\n            var minVal;\n            if (arrCharsIds[c] == \"nLength\") { minVal = parseInt(minLength - 1); } else { minVal = 0; }\n            if (arrChars[c] == parseInt(minVal + 1)) { nReqChar++;}\n            else if (arrChars[c] > parseInt(minVal + 1)) { nReqChar++;}\n        }\n        let nRequirements = nReqChar;\n        var nMinReqChars;\n        if (password.length >= minLength) { nMinReqChars = 3; } else { nMinReqChars = 4; }\n        if (nRequirements > nMinReqChars) {  // One or more required characters exist\n            nScore = parseInt(nScore + (nRequirements * 2));\n        }\n\n        if (nScore > 100) { nScore = 100; } else if (nScore < 0) { nScore = 0; }\n\n        return nScore;\n    }\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}